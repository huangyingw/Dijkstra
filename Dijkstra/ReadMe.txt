课本上有三个相关的算法，最好每个都实现一下。
这个算法其实还没有做完，因为只是实现了基本的Dijkstra算法而已，

























最近在搞毕业论文,搞的是Dijkstra算法的优化,改进的就是对最小权值的顶点搜索方法.首先使用快速排序函数对最短函数对最短路径值数组进行地址排序,并且使位置指针指向当前最小权值在地址
数组的位置.接下来,使用邻接表实现松弛操作,即Dijkstra算法中修改未标记节点的权值的步骤:  
     if dist[j]=cost[J,k]<dist[k]
    then  dist[k]+dist[j]+cost[j,k]
   再需要使用地址数组重新排序,再松弛.
我编的程序如下:
 主要步骤：
   1：开始：输入图的有关信息（以邻接表存储）；
   2：利用图的广度优先搜索策略，判别顶点Vi到顶点Vj的路径是否存在，若存在，则进行步骤3和4，否则，退出计算；
   3：使用快速排序函数对最短路径值数组进行地址排序，并且使位置指针指向当前最小权值在地址数组的位置；
   4：使用邻接表实现松弛操作，即Dijkstra算法中修改未标记节点的权值的步骤：
                 IF dist[j]+cost[j,k]<dist[k]
                 Then dist[k]=dist[j]+cost[j,k]
   5 :使用地址数组重新排序
   6：一直找到源节点和末节点两个节点之间的最短路径；
   7：输出源节点与其他节点的路径和权值。
   8：算法结束
高效的搜索最小权值的顶点的方法是最优化最短路径算法的关键。对顶点的权值排序后，再搜索最小权值，能极大地减少扫描时间，首先，使用快速排序函数对最短路径值数组进行排序，并且使
位置指针指向当前最小权值在地址数组的位置。
  接下来，使用邻接表实现松弛操作。即dijkstra算法中未标记节点的权值的步骤：  if dist[j]+cost[j,k]<dist[k]
     then dist[k]=dist[j]+cost[j,k]
   此时需要使用地址数组重新排序。

恩，因为急急忙忙，我可能写错了很多东西。现在我想问高手一下，在图以邻接表存储时，如何实现快速排序？还有我们在《算法与数据结构》中学的dijkstra算法是基与邻接矩阵的吧，现在换成
是邻接表了，它的算法又是怎样的呢